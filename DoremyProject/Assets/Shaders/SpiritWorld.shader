Shader "Custom/SpiritWorld" {
	Properties {
		[PerRendererData]_MainTex ("Sprite Texture", 2D) = "white" {}
		_NoiseTex("Noise Texture", 2D) = "white" { }

		_Frequency("Wave Frequency", Range(5, 100)) = 10
		_Scale("Wave Scale", Range(10, 5000)) = 30
		_Divider("Divider", Range(0.5, 50)) = 20

		_Radius("Radius", Range(0, 1)) = 0.5
		_Border("Anti Alias Border Threshold", Range(0.00001, 5)) = 0.01
	}

	SubShader {
		Tags {
			"Queue" = "Transparent"
			"IgnoreProjector" = "True"
			"RenderType" = "Opaque"
		}

		ZWrite On
		Lighting Off
		Cull Off
		Fog{ Mode Off }
		Blend One Zero

		GrabPass {}	// Grab pass to get texture behind material attached object

		Pass {
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			
			#include "UnityCG.cginc"

			struct vertInput {
				float4 vertex : POSITION0;
				float2 uv : TEXCOORD0;
			};

			struct vertOutput {
				float4 vertex : POSITION;
				float2 uv : TEXCOORD0;
				float4 grabPos : TEXCOORD1;
			};

			sampler2D _MainTex;
			sampler2D _MainTex_ST;
			sampler2D _GrabTexture; // Automatically generated by the GrabPass
			sampler2D _NoiseTex;

			half _Frequency;
			half _Scale;
			half _Divider;

			float _Radius;
			float _Border;

			vertOutput vert (vertInput v) {
				vertOutput o;

				o.vertex  = UnityObjectToClipPos(v.vertex);
				o.uv	  = v.uv;
				o.grabPos = ComputeGrabScreenPos(o.vertex);

				return o;
			}

			float2 antialias(float radius, float borderSize, float dist) {
                float t = smoothstep(radius + borderSize, radius - borderSize, dist);
                return t;
            }

			fixed4 frag (vertOutput i) : COLOR {
                float2 center = float2(0.5, 0.5);
                float maxRadius = 0.5;
                float dis = distance(i.uv, center);

				float2 displacedTexCoord = UNITY_PROJ_COORD(i.grabPos) + float2(tex2D(_NoiseTex, i.vertex.xy / _Scale + float2(_SinTime.w, _CosTime.w) / _Frequency).xy - 0.5) / _Divider;

				fixed4 bgcolor = tex2D(_GrabTexture, displacedTexCoord);
				fixed4 col = half4(1 - bgcolor.r, 1 - bgcolor.g, 1 - bgcolor.b, bgcolor.a); // Negative colors

				float radius = maxRadius * _Radius;
				float aliasVal = antialias(radius, _Border, dis);
                col = lerp(bgcolor, col, aliasVal);

				return col;
			}
			ENDCG
		}
	}
}
